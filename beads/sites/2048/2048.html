<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Game2048</title>
<link rel="shortcut icon" href="data:,">
<style>
/*  the above empty icon shuts the favicon stuff up.
	put stmt above style if you want favicon: <link rel="shortcut icon" href="favicon.ico" />
    this disables the annoying double click highlighting of DIV blocks  */
div { outline-style:none;}
/*  this customizes the default scrollbar appearance */
::-webkit-scrollbar { width: 12pt; }
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 15px grey; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb {
    background: OliveDrab; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb:hover {
    background: Olive; }
</style>
</head>
<body style="margin:0; padding:0;">
<script type="module">
import { U, Y, N, POP, VAL, VNP, setv, gets, getn, addr } from '../../runtime_039/beads_std.js';
import * as std from '../../runtime_039/beads_std.js';
import * as str from '../../runtime_039/beads_str.js';
import * as k   from '../../runtime_039/beads_k.js';
export const CODE_HASH= 0x30a37d88;
const _M = "Game2048";
std.rtl_init();
std.aaaa.main_init = main_init;
std.aaaa.main_module = "Game2048";
std.aaaa.main_drawer = new std.a_function("Game2048", "main_draw", main_draw);
//------- enums
const F_noMoreMoves=9007193935798764; std.g_enum_ss[9007193935798764]="noMoreMoves";
std.FIELDS[F_noMoreMoves] = true;
const R_game=9007192591338094; std.g_enum_ss[9007192591338094]="game";
const F_won=9007191862969040; std.g_enum_ss[9007191862969040]="won";
std.FIELDS[F_won] = true;
//[reflAAA]
std.merge_lit(_M,0,std.META,_M, std.F_mod_const, "colors", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "gap", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, std.F_mod_funcs, "addTile"
, std.F_vv_funck, VAL, std.FK_CALC, POP, "canMove", std.F_vv_funck, VAL, std.FK_CALC, POP, "d_board", std.F_vv_funck, VAL, std.FK_DRAW, POP, "execMove", std.F_vv_funck, VAL, 
std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "dir", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "init_board", std.F_vv_funck
, VAL, std.FK_CALC, POP, "main_draw", std.F_vv_funck, VAL, std.FK_DRAW, POP, "main_init", std.F_vv_funck, VAL, std.FK_CALC, POP, "trymove", std.F_vv_funck, VAL, std.FK_CALC
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "p1", std.F_vv_typek, VAL, std.TYPE_NUM, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "ix", std.F_vv_typek, VAL, std.TYPE_NUM, POP, 3, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "iy", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, POP, 
std.F_mod_recs, "game", std.F_vv_fields, "noMoreMoves", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "won", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, POP, std.F_mod_vars
, "blanks", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "board", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "color", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "g", std.F_vv_rec
, VAL, "game", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "moved", std.F_vv_typek, VAL, std.TYPE_YESNO);
//[reflZZZ]
//-------  func const
const init_board_F = new std.a_function("_M", "init_board", init_board);
std.FUNCS[init_board_F.hash]=init_board_F;
const d_board_F = new std.a_function("_M", "d_board", d_board, track_d_board);
std.FUNCS[d_board_F.hash]=d_board_F;
const addTile_F = new std.a_function("_M", "addTile", addTile);
std.FUNCS[addTile_F.hash]=addTile_F;
const canMove_F = new std.a_function("_M", "canMove", canMove);
std.FUNCS[canMove_F.hash]=canMove_F;
//-------  top nodes
const gap = 4;
const colors = new std.a_tree("Game2048","colors", std.NF_TOPLEVEL|std.NF_LOGGED, std.tree_lit(_M, 6, 1, VAL, 0xCDC1B4, 2, VAL, 0xEEE4DA, 3, VAL, 0xEDE0C8, 4, VAL, 0xF2B179
, 5, VAL, 0xF59563, 6, VAL, 0xF67C5F, 7, VAL, 0xF65E3B, 8, VAL, 0xEDCF72, 9, VAL, 0xEDCC61, 10, VAL, 0xEDC850, 11, VAL, 0xEDC53F, 12, VAL, 0xEDC22E, 13, VAL, 0xEDC22E));
let board = new std.a_tree("Game2048","board", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let g = new std.a_tree("Game2048","g", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let blanks = U;
let moved = U;
let color = U;

//====================
//   d_board
//====================
function d_board(b) {
k.k_enter(b);
k.div_begin(b, new std.a_function(_M, "d_board_cell", d_board_cell, null), false, false, false);
  k.div_spa(b, 0, gap, std.al);
  var loop355 = new std.a_loop({ limit:4 });
  while (loop355.next()) {
    k.div_add(b, U, 0, 40, std.al, null, 0);
    k.div_spa(b, 0, gap, std.al);
  }
  k.div_spa(b, 1, gap, std.al);
  var loop356 = new std.a_loop({ limit:4 });
  while (loop356.next()) {
    k.div_add(b, U, 1, 40, std.al, null, 0);
    k.div_spa(b, 1, gap, std.al);
  }
  k.div_end(b);
  //--under
  std.draw_rect(b, { fill:0xBBADA0 });
  k.draw_grid(b);
  //--over
  if ((getn(g, F_won) === Y || getn(g, F_noMoreMoves) === Y)) {
    let msg = null;
    if (getn(g, F_won) === Y) {
      color = std.DODGER_BLUE;
      msg = "Congratulations!\nYou made it.\n2048";
    }
    if (getn(g, F_noMoreMoves) === Y) {
      color = std.RED;
      msg = "Game over.";
    }
    std.draw_rect(b, { fill:color, thick:std.pt_to_dots(b, 0), opacity:0.8 });
    std.draw_str(b, msg, { size:0.5, bold:Y, vert:0.1, color:std.YELLOW });
    std.draw_str(b, "Press any key.", { bold:Y, vert:0.9, color:std.YELLOW });
  }
k.k_leave(b);
}


//====================
//   d_board_cell
//====================
function d_board_cell(b) {
  k.k_enter(b);
  let v = U;
  let ix = std.round(std.lg(getn(board, getn(b.extra, std.F_cell_seq)), { base:2 }), {});
  ix = std.gt2(ix, 12) ? 13 : std.gt2(ix, 0) ? std.add(ix, 1) : 1;
  color = std.get_generic(colors, ix);
  v = std.is_numeric(getn(board, getn(b.extra, std.F_cell_seq))) === Y ? getn(board, getn(b.extra, std.F_cell_seq)) : "";
  std.draw_rect(b, { fill:color, thick:std.pt_to_dots(b, 0) });
  std.draw_str(b, v, { size:0.5, bold:Y });
  k.k_leave(b);
}

//====================
//   track_d_board
//====================
function track_d_board(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    var case357 = getn(b.extra, std.F_cell_seq);
    if (case357 === 2 || case357 === 3) {
      execMove(std.KEYCODE_UP);
    } else if (case357 === 5 || case357 === 9) {
      execMove(std.KEYCODE_LEFT);
    } else if (case357 === 8 || case357 === 12) {
      execMove(std.KEYCODE_RIGHT);
    } else if (case357 === 14 || case357 === 15) {
      execMove(std.KEYCODE_DOWN);
    }
    return Y;
  return Y;
  } else 
  //---------------
  //   on EV_KEYBOARD
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_KEYBOARD) {
    execMove(getn(e, std.F_keycode));
    return Y;
  return Y;
  }
  return N;
}

//====================
//   main_draw
//====================
export function main_draw(b) {
k.k_root2(b);
k.k_enter(b);
  var b50=k.k_layer(b, d_board_F, { area:std.solve_rect({ basis:addr(b.extra, std.F_box), pin:std.MID_CENTER, aspect:1 }) });
  d_board(b50);
k.k_leave(b);
}


//====================
//   addTile
//====================
function addTile() {
  let v = std.gt2(std.random(), 0.9) ? 4 : 2;
  let p = std.random_int(1, blanks);
  blanks = std.sub(blanks, 1);
  var loop358 = new std.a_loop({ limit:16 });
  while (loop358.next()) {
  var ix = loop358.count;
    if (std.is_numeric(getn(board, ix)) === Y) {
      continue;
    }
    p = std.sub(p, 1);
    if (std.eq2(p, 0)) {
      std.path_setv(_M, 31, std.addr(board, ix), v);
      break;
    }
  }
}


//====================
//   canMove
//====================
function canMove() {
  let p = 1;
  std.path_setv(_M, 37, std.addr(g, F_noMoreMoves), N);
  if (std.gt2(blanks, 0)) {
    return;
  }
  var loop359 = new std.a_loop({ limit:4 });
  while (loop359.next()) {
    var loop360 = new std.a_loop({ limit:3 });
    while (loop360.next()) {
      if ((std.eq2(getn(board, p), getn(board, std.add(p, 1))) || std.eq2(getn(board, p), getn(board, std.add(p, 4))))) {
        return;
      }
      p = std.add(p, 1);
    }
    p = std.add(p, 1);
  }
  std.path_setv(_M, 46, std.addr(g, F_noMoreMoves), Y);
}


//====================
//   execMove
//====================
function execMove(dir) {
  if (getn(g, F_won) === Y) {
    std.path_setv(_M, 53, std.addr(g, F_won), N);
    return;
  }
  if (getn(g, F_noMoreMoves) === Y) {
    init_board();
    return;
  }
  moved = N;
  var case361 = dir;
  if (case361 === std.KEYCODE_UP) {
    trymove(1, 4, 1);
  } else if (case361 === std.KEYCODE_LEFT) {
    trymove(1, 1, 4);
  } else if (case361 === std.KEYCODE_DOWN) {
    trymove(13, -4, 1);
  } else if (case361 === std.KEYCODE_RIGHT) {
    trymove(4, -1, 4);
  }
  if (moved === Y) {
    moved = N;
    addTile();
  }
  canMove();
}


//====================
//   init_board
//====================
function init_board() {
  std.copy_tree(_M, 76, std.tree_lit(_M, 76), std.addr(board));
  blanks = 16;
  addTile();
  addTile();
  std.path_setv(_M, 80, std.addr(g, F_won), N);
  std.path_setv(_M, 81, std.addr(g, F_noMoreMoves), N);
}


//====================
//   main_init
//====================
export function main_init() {
  init_board();
}


//====================
//   trymove
//====================
function trymove(p1, ix, iy) {
  let x1 = U;
  let x2 = U;
  var loop362 = new std.a_loop({ limit:4 });
  while (loop362.next()) {
    x1 = p1;
    x2 = std.add(p1, ix);
    p1 = std.add(p1, iy);
    var loop363 = new std.a_loop({ limit:3 });
    while (loop363.next()) {
      if (getn(board, x2) === U) {
        x2 = std.add(x2, ix);
      } else if (getn(board, x1) === U) {
        std.path_setv(_M, 100, std.addr(board, x1), getn(board, x2));
        std.path_setv(_M, 101, std.addr(board, x2), U);
        x2 = std.add(x2, ix);
        moved = Y;
      } else if (std.eq2(getn(board, x1), getn(board, x2))) {
        std.path_setv(_M, 105, std.addr(board, x1), std.mul(getn(board, x1), 2));
        if (std.eq2(getn(board, x1), 2048)) {
          std.path_setv(_M, 107, std.addr(g, F_won), Y);
        }
        blanks = std.add(blanks, 1);
        moved = Y;
        std.path_setv(_M, 110, std.addr(board, x2), U);
        x1 = std.add(x1, ix);
        x2 = std.add(x2, ix);
      } else {
        x1 = std.add(x1, ix);
        if (getn(board, x1) === U) {
          std.path_setv(_M, 116, std.addr(board, x1), getn(board, x2));
          std.path_setv(_M, 117, std.addr(board, x2), U);
          moved = Y;
        }
        x2 = std.add(x2, ix);
      }
    }
  }
}

main_init();
k.rebuild_all();

</script>
</body>
</html>
