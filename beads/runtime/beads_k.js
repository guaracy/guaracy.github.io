import{a_function,a_gradient,a_image,a_loom_element,a_meas,a_sound,a_tree,a_path}from"./beads_std.js";import*as std from"./beads_std.js";import*as str from"./beads_str.js";const TRACE_AUTO=!1,TRACE_BLOCKS=!1,TRACE_CAPTURE=!1,TRACE_DPI=!1,TRACE_ENTER=!1,TRACE_EXPLODE=!1,TRACE_EXTRA=!1,TRACE_EVENTS=!1,TRACE_FIND=!1,TRACE_FINDBX=!1,TRACE_GRID=!1,TRACE_K=!1,TRACE_LOGGING=!1,TRACE_OBSOLETE=!1,TRACE_TRICKLE=!1,TRACE_SCROLL=!1,TRACE_TBL=!1,TRACE_VISIT=!1,TRACE_XFORM=!1,TRACE_XTRA=!1,TRACE_XY=!1,TRACE_GTOL=!1,OBBLOCK="$root",M="std",MARK_OVERFLOW=!1;export const SKIPBG=!1;export const DUMMY_ROW_CONTENT=!1;export const SKIP_SLICE=-1;export const DIVF_VERT=1;export const DIVF_FINGER=2;export const BKIND_ROOT=0;export const BKIND_PLAIN=1;export const BKIND_SUBSET=2;export const BKIND_GRID_BASE=3;export const BKIND_GRID_CELL=4;export const BKIND_SLICE=5;export const BKIND_SCROLL=6;export const BKIND_TABLE_BASE=7;export const BKIND_TABLE_ROW=8;export const BKIND_OVERLAY=9;export const BKIND_MEASURING=10;export const BKIND_MENUBAR=11;export const NODRAW=null;export const NOTRACK=null;export const NOCALC=null;export const NOCELLTRACK=null;export const ROOT_BLABEL="$root";const LOG_DRAW=!1;let DRAW_EVENT,g_last_drawn_seq,g_first_mon_draw;export const SCROLL_SMALL_STEP=1/12;export const SCROLL_BIG_STEP=.95;export let g_interface_locked;export let g_root_block=null;export let g_root2_block=null;export let g_menu_block=null;export let g_capture_bid;export let g_capture_block;export let g_last_majorx;export let g_field_mark_func;export let g_fields_to_mark;export let gg_depth;export let g_curr_block=null;export let g_block_stack=[];let g_logged,g_print_options=null;function a_col_measure(t,e){this.width=t,this.unit=e}function a_tbl_col(t,e,s){this.colid=t,this.startcol=e,this.stopcol=s,this.startdot=0,this.stopdot=0}function a_tbl_row(t,e,s){this.rowkind_ptr=t,this.rowid=e,this.rowbox=null,this.rowextra=s}function a_tbl_rowkind(t,e){this.kindID=t,this.curcolx=1,this.curspanx=1,this.rowdrawf=e,this.fields=[]}function a_tbl_spec(){this.backcolor=std.U,this.prepped=!1,this.nrows=0,this.tot_height=0,this.rawgrid=[],this.rawdots=[],this.rowm=[],this.rows=[],this.s=[]}export function k_root2(t){g_root2_block=t};function capture_mouse(t){TRACE_CAPTURE&&std.logg("capture_mouse by "+t.blabel),0!=g_capture_bid&&std.argument_err("nested calls to capture not supported"),g_capture_bid=t.bid,g_capture_block=t}function release_mouse(){TRACE_CAPTURE&&std.logg("release_mouse"),g_capture_bid=0,g_capture_block=null}export function k_layer(t,e,s){let o,d,r,l,_,n,i=null,a=std.U,c=t.bounds.height,b=0,g=1,u=std.U,f=0,p=0,h=0,x=0,E=0,v=t.bounds.width;for(let e in s)switch(e){case"area":b=std.getn(s.area,std.F_left),h=std.getn(s.area,std.F_top),v=std.getn(s.area,std.F_width),c=std.getn(s.area,std.F_height);break;case"indent":_=s.indent,b=t.bounds.left+_,h=t.bounds.top+_,v=t.bounds.width-2*_,c=t.bounds.height-2*_;break;case"canvas":i=s.canvas;break;case"in_t":l=s.in_t;break;case"in_r":r=s.in_r;break;case"in_b":o=s.in_b;break;case"in_l":d=s.in_l,b=t.bounds+d,h=t.bounds+l,v=t.bounds.width-d-r,c=t.bounds.height-l-o;break;case"opacity":std.is_numeric(s.opacity)!=std.Y&&std.argument_err("bad arg"),g=s.opacity;break;case"pin":std.is_numeric(s.pin)!=std.Y&&std.argument_err("bad arg"),u=s.pin;break;case"dpi":std.is_numeric(s.dpi)!=std.Y&&std.argument_err("bad arg"),a=s.dpi;break;case"tx":std.is_numeric(s.tx)!=std.Y&&std.argument_err("bad arg"),b=s.tx;break;case"ty":std.is_numeric(s.ty)!=std.Y&&std.argument_err("bad arg"),h=s.ty;break;case"skewx":std.is_numeric(s.skewx)!=std.Y&&std.argument_err("bad arg"),f=s.skewx;break;case"skewy":std.is_numeric(s.skewy)!=std.Y&&std.argument_err("bad arg"),p=s.skewy;break;default:std.argument_err("### bad property in options: "+e)}if(!std.CHECKS||std.is_numeric(b)==std.Y&&std.is_numeric(h)==std.Y&&std.is_numeric(v)==std.Y&&std.is_numeric(c)==std.Y||std.argument_err("bad bounds"),null!=i){var w=document.createElement("canvas");w.id=t.blabel+":canvas",w.width=v,w.height=c,w.style.left=String(b)+"px",w.style.top=String(h)+"px",w.style.width=String(v)+"px",w.style.height=String(c)+"px",w.style.position="absolute",t.appendChild(w),(n={}).bounds=new std.Rectangle(0,0,v,c),n.can=w,n.ctx=w.getContext("2d");var k=new a_tree(M,"$new_layer");std.setv(M,0,k,std.F_box,std.F_left,0),std.setv(M,0,k,std.F_box,std.F_top,0),std.setv(M,0,k,std.F_box,std.F_width,v),std.setv(M,0,k,std.F_box,std.F_height,c),n.extra=k,std.setv(M,0,i,std.F_width,v),std.setv(M,0,i,std.F_height,c),std.setv(M,0,i,std.F_sysobj,n)}else if((n=std.new_block(t,new std.Rectangle(b,h,v,c),BKIND_SUBSET,e.name,e,null,t.dest)).style.opacity=g,a!=std.U&&(n.dpi=a),5==u){x=v/2,E=c/2;var m=std.js_svg_wrapper(n,g),R=document.createElementNS(std.SVG_NS,"g");R.setAttribute("transform",`translate(${x} ${E})`),m.appendChild(R),n.last_svg_ptr=R,n.bkind=BKIND_SUBSET}return n};export function k_set_bounds(t,e){t.style.left=e.left,t.style.top=e.top,t.style.width=e.width,t.style.height=e.height,t.bounds=new std.Rectangle(0,0,e.width,e.height),std.setv(M,0,t.extra,std.F_box,std.F_left,0),std.setv(M,0,t.extra,std.F_box,std.F_top,0),std.setv(M,0,t.extra,std.F_box,std.F_width,e.width),std.setv(M,0,t.extra,std.F_box,std.F_height,e.height),std.setv(M,0,t.extra,std.F_boxtot,std.F_left,0),std.setv(M,0,t.extra,std.F_boxtot,std.F_top,0),std.setv(M,0,t.extra,std.F_boxtot,std.F_width,e.width),std.setv(M,0,t.extra,std.F_boxtot,std.F_height,e.height)};function snap_rectangle(t){let e=Math.round(t.left),s=Math.round(t.top),o=Math.round(t.left+t.width),d=Math.round(t.top+t.height);return new std.Rectangle(e,s,o-e,d-s)}export function refresh_all(t=!1){g_last_drawn_seq=0,g_root_block.bseq=1,t&&(g_menu_block.bseq=1)};export function in_to_dots(t,e,s=!1){let o;return t.dest==std.FOR_PRINT?o=e*std.getn(g_print_options,std.PRINT_RESOLUTION):(o=e*std.SCREEN_DPI,s?Math.round(o):o)};export function unit_to_pixels(t,e,s,o=!1){let d;switch(d=0,s){case std.al:std.argument_err("asking for phys size of a non-physical unit");break;case std.px:d=o?Math.round(e):e;break;case std.pt:d=std.pt_to_dots(t,e),o&&(d=Math.round(d));break;case std.pc:d=std.pt_to_dots(t,12*e),o&&(d=Math.round(d));break;default:std.argument_err("unsupported unit type")}return d};export function draw_err_box(t,e,s){std.draw_rect(t,s,{fill:16711680})};export function k_enter(t){t.nesting+=1,1==t.nesting?(g_block_stack.push(g_curr_block),g_curr_block=t,t.usesz.length=0,k_del_all_children(t),t.div=null,t.tbl=null,TRACE_ENTER&&std.logg(str.conv("k_enter, "+t.blabel+", bounds={rect}, scroll={rect}, seq={n}",t.bounds,t.scrollRect,t.bseq))):TRACE_K&&std.logg("...ignoring nested block "+t.blabel)};export function k_leave(t){t.nesting-=1,std.CHECKS&&(t.nesting<0&&std.internal_err("block was left more times than entered "+t.blabel),null!=t.div&&t.div.open&&std.internal_err("forgot to call div_end before leaving this block!")),0==t.nesting&&(g_curr_block=g_block_stack.pop(),t.bseq=std.g_currseq,TRACE_ENTER&&std.logg(str.conv("..k_leave, "+t.blabel+", seq={n}",t.bseq)))};export function k_push(t){std.internal_err("not yet implemented")};export function k_pop(t){std.internal_err("not yet implemented")};export function k_inset_to_rect(t,e,s=null){let o;s(o=std.new_block(t,e,BKIND_SUBSET,t.blabel+":inset",s,t.dest))};export function k_inset(t,e,s,o,d,r,l,_=NOTRACK){let n,i,a,c,b;TRACE_K&&std.logg("k_inset on block "+t.blabel),n=0,i=0,a=0,c=0,std.is_numeric(e)==std.Y&&e>=0?n=unit_to_pixels(t,e,r):std.CHECKS&&std.argument_err("invalid inset"),std.is_numeric(s)==std.Y&&s>=0?i=unit_to_pixels(t,s,r):std.CHECKS&&std.argument_err("invalid inset"),std.is_numeric(o)==std.Y&&o>=0?a=unit_to_pixels(t,o,r):std.CHECKS&&std.argument_err("invalid inset"),std.is_numeric(d)==std.Y&&d>=0?c=unit_to_pixels(t,d,r):std.CHECKS&&std.argument_err("invalid inset"),b=new std.Rectangle(t.bounds.left+c,t.bounds.top+n,t.bounds.width-c-a,t.bounds.height-n-i),TRACE_K&&std.logg(str.conv("after inset of {n1},{n1},{n1},{n1}, bounds {rect}",n,i,a,c,b)),k_inset_to_rect(t,b,l,_)};export function k_indent_to_net(t,e,s,o,d,r,l=NOTRACK){let _,n,i,a,c,b,g,u;!std.CHECKS||std.is_numeric(o)==std.Y&&std.is_numeric(d)==std.Y&&std.is_numeric(e)==std.Y&&std.is_numeric(s)==std.Y||std.argument_err("non-numeric inputs"),o=Math.max(0,Math.min(1,o)),d=Math.max(0,Math.min(1,d)),_=e,i=Math.max(0,t.bounds.width-_),n=s,a=Math.max(0,t.bounds.height-n),u=Math.round(i*o),g=Math.max(0,i-u),c=Math.round(a*d),b=Math.max(0,a-c),TRACE_K&&std.logg(str.conv("indent_to_net, targ {n},{n}, pixels {n},{n}, excess {n},{n}",e,s,_,n,i,a)),k_inset(t,c,b,g,u,std.px,r,l)};export function tbl_begin(t){let e;return TRACE_K&&std.logg("tbl_begin"),e=new a_tbl_spec,t.tbl=e,e};function calc_physical(t,e,s,o,d){let r,l,_,n,i,a,c,b;for(b=0,r=0,i=0,_=0;_<o.length;)o[_].unit==std.al?(i+=1,r+=o[_].width,d[_]=0):(a=unit_to_pixels(t,o[_].width,o[_].unit),d[_]=a,b+=a),_+=1;if(0!=i){for(l=(n=e-b)/r,b=0,_=0;_<o.length;)o[_].unit==std.al?(a=o[_].width*l,d[_]=a,b+=a):b+=d[_],_+=1;for(n=e-b,n=e-b-i*(c=Math.floor(n/i)),_=0;_<o.length;)o[_].unit==std.al&&(d[_]+=c,b+=c,n>0&&(d[_]+=1,b+=1,n-=1)),_+=1}return b}export function tbl_begin_rows(t){let e,s,o,d,r=t.tbl.rawgrid,l=t.tbl.rawdots,_=t.tbl;for(d in _.prepped&&std.argument_err("double call of tbl_end!"),_.prepped=!0,_.tot_width=calc_physical(t,t.bounds.width,t.bounds.height,r,l),e=[],s=0,r)e.push(s),s+=l[d];for(o in e.push(s),_.s)for(d in _.s[o].fields)std.CHECKS&&(_.s[o].fields[d].startcol-1>=r.length||_.s[o].fields[d].startcol>_.s[o].fields[d].stopcol||_.s[o].fields[d].stopcol-1>=r.length)&&std.argument_err("logical columns not reasonable"),_.s[o].fields[d].startdot=e[_.s[o].fields[d].startcol-1],_.s[o].fields[d].stopdot=e[_.s[o].fields[d].stopcol]};export function tbl_end_rows(t){let e,s,o,d,r,l,_,n,i=t.tbl;for(s in e=new Array(i.rowm.length),o=calc_physical(t,t.bounds.height,t.bounds.width,i.rowm,e),d=0,i.rows)l=d,n=d+=e[s],r=0,_=Math.min(i.tot_width,t.bounds.width),i.rows[s].rowbox=new std.Rectangle(r,l,_-r,n-l),TRACE_K&&std.logg(str.conv("  row={}, rowbox={rect}",s,i.rows[s].rowbox));i.tot_height=o,TRACE_BLOCKS&&std.logg("..end tbl_end, nrows="+i.nrows)};export function tbl_draw(t,e){let s,o,d,r,l,_,n,i,a=!0;for(n=t.tbl,std.is_numeric(n.backcolor)==std.Y&&(SKIPBG?std.draw_rect(t,t.bounds,{fill:std.WHITE}):std.draw_rect(t,t.bounds,{fill:n.backcolor})),r=0,t.dest==std.FOR_SCREEN&&null!=t.horz_scroll_link&&(r=-std.getn(t.horz_scroll_link,std.F_s_position)),l=0,t.dest==std.FOR_SCREEN?t.vert_scroll_link&&(l=-std.getn(t.vert_scroll_link,std.F_s_position)):l=-n.rows[e].rowbox.top,TRACE_TBL&&std.logg(str.conv("tbl_draw, bounds={rect}, scroll={rect}, nsect={}, startrow={}, nrows={}, dx={}, dy={}",t.bounds,t.scrollRect,n.s.length,e,n.nrows,r,l)),o=e;o<n.nrows;){if((s=(i=n.rows[o]).rowid)!=std.U){if(_=std.solve_rectR({basis:i.rowbox,dx:r,dy:l}),TRACE_TBL&&std.logg(str.conv("  rowbox after adjustment {rect}, was {rect}",_,i.rowbox)),_.bottom<t.bounds.top){TRACE_TBL&&std.logg("  ..row not yet visible"),o+=1;continue}if(_.top>t.bounds.bottom){TRACE_TBL&&std.logg("..row past bottom");break}if(t.dest==std.FOR_PRINT&&_.bottom>t.bounds.bottom&&!a){TRACE_TBL&&std.logg("..stopping, print row will get truncated");break}if(a=!1,TRACE_TBL&&std.logg(str.conv("rowback rowx={}, net={rect}",o,_)),DUMMY_ROW_CONTENT)std.draw_rect(t,_,{fill:std.rgb255(std.random_range_int(100,255),std.random_range_int(100,255),std.random_range_int(100,255)),opacity:.5}),std.draw_str(t,str.to_str(o),_,{size:std.pt_to_dots(t,10)});else{let e=i.rowkind_ptr.rowdrawf;std.setv(M,0,t.extra,std.F_cell_id,std.F_y,s),std.setv(M,0,t.extra,std.F_cell,std.F_y,o),std.setv(M,0,t.extra,std.F_box,std.F_left,_.left),std.setv(M,0,t.extra,std.F_box,std.F_top,_.top),std.setv(M,0,t.extra,std.F_box,std.F_width,_.width),std.setv(M,0,t.extra,std.F_box,std.F_height,_.height),e(t,i)}}o+=1}return d=o,TRACE_TBL&&std.logg(str.conv("..end table draw, startrow={}, endrow={}",e,d)),d};export function tbl_rawgrid_add(t,e,s){t.push(new a_col_measure(e,s))};export function tbl_begin_rowkind(t,e,s){t.push(new a_tbl_rowkind(e,s))};export function tbl_rowkind_span(t,e,s){let o=t[t.length-1];e&&(o.fields.push(new a_tbl_col(o.curspanx,o.curcolx,o.curcolx+s-1)),o.curspanx+=1),o.curcolx+=s};export function tbl_calc_field(t,e,s){let o=e.rowbox.top,d=e.rowbox.height,r=e.rowkind_ptr,l=r.fields[s-1].startdot,_=r.fields[s-1].stopdot-l;std.setv(M,0,t.extra,std.F_box,std.F_left,l),std.setv(M,0,t.extra,std.F_box,std.F_top,o),std.setv(M,0,t.extra,std.F_box,std.F_width,_),std.setv(M,0,t.extra,std.F_box,std.F_height,d),std.setv(M,0,t.extra,std.F_cell,std.F_x,s)};export function tbl_find_rowkind(t,e){let s;for(s in e)if(e[s].kindID==t)return e[s];return null};export function tbl_add_spa(t,e,s){t.rowm.push(new a_col_measure(e,s)),t.rows.push(new a_tbl_row(null,std.U,null)),t.nrows+=1};export function tbl_add_row(t,e,s,o,d,r=null){let l;null==(l=tbl_find_rowkind(o,t.s))&&std.argument_err("section id never defined"),t.rowm.push(new a_col_measure(e,s)),t.rows.push(new a_tbl_row(l,d,r)),t.nrows+=1};export function div_begin(t,e=null,s=!1,o=!1,d=!1){TRACE_SCROLL&&std.logg(str.conv("div_begin {str}, scrh={}, scrv={}, bounds={rect}, scroll={rect}",t.blabel,o,d,t.bounds,t.scrollRect)),t.div=new std.a_div_spec(e,s,o,d),o?(t.style.overflowX="scroll",t.addEventListener("scroll",std.js_scroll)):t.style.overflowX="hidden",d?(t.style.overflowY="scroll",t.addEventListener("scroll",std.js_scroll)):t.style.overflowY="hidden"};function order_slices(t,e){return t.draw_order==e.draw_order?t.box.top<e.box.top?-1:t.box.top>e.box.top?1:t.box.left<e.box.left?-1:t.box.left>e.box.left?1:0:t.draw_order<e.draw_order?-1:1}export function scroll_block_id(t,e,s){let o;TRACE_SCROLL&&std.logg(">> scroll_block_id"),null!=(o=k_find_block_by_id(g_root_block,t))?(TRACE_SCROLL&&std.logg(str.conv("scroll_block_id, blabel={str}, id={n}, x={n}, y={n}, scroll={rect}",o.blabel,o.bid,e,s,o.scrollRect)),null!=o.div?(TRACE_SCROLL&&std.logg("  scrolling a div block"),o.scrollRect=new std.Rectangle(o.bounds.left+e,o.bounds.top+s,o.bounds.width,o.bounds.height)):null!=o.tbl?(TRACE_SCROLL&&std.logg("  refreshing a tbl"),tbl_draw(o,0)):std.internal_err("block kind not allowed to have scrollbar")):std.internal_err("content block is missing!")};export function slices_compute(t,e,s,o,d,r,l){let _,n,i,a,c,b,g,u,f,p,h,x,E,v,w,k,m=0==(s&DIVF_VERT);if(E=t.bounds.width,v=t.bounds.height,0!=(i=d.length)){for(f=0,a=0,n=0,u=new Array(i),_=0;_<i;_++)(w=d[_]).unit==std.al?(n+=1,a+=w.mag,u[_]=0):(g=unit_to_pixels(t,w.mag,w.unit),u[_]=g,f+=g);if(o)m?E=f:v=f;else{if(h=0,x=0,(b=r-f)<0){let t=r/f;for(_=0;_<i;_++)(w=d[_]).unit!=std.al&&(u[_]*=t)}if(b>0){if(0!=n)for(c=b/a,_=0;_<i;_++)(w=d[_]).unit==std.al?(g=w.mag*c,u[_]=g,f+=g):f+=u[_]}else b<0&&(0==(s&DIVF_VERT)?h=-b:x=-b,TRACE_K&&std.logg(str.conv("div slice overflow, avail={n}, scroll_limit={n}",r,-b)))}if(0==(s&DIVF_VERT))for(p=t.bounds.left,_=0;_<i;_++)d[_].box=new std.Rectangle(p,t.bounds.top,u[_],t.bounds.height),p+=u[_];else for(p=t.bounds.top,_=0;_<i;_++)d[_].box=new std.Rectangle(t.bounds.left,p,t.bounds.width,u[_]),p+=u[_];if(TRACE_K)for(std.logg("..end slices_compute:"),_=0;_<i;_++)k=d[_].id!=SKIP_SLICE?d[_].drawer.name:"-space-",std.logg(str.conv(" slices[{}] "+k+", box={rect}, id={}",_,d[_].box,d[_].id));d.sort(order_slices)}return m?E:v};export function draw_grid(t){let e,s,o,d,r,l,_=t.div;for(d=1,s=0;s<_.horz_slices.length;s++)if(_.horz_slices[s].id!=SKIP_SLICE){for(o=1,e=0;e<_.vert_slices.length;e++)if(_.vert_slices[e].id!=SKIP_SLICE){l=new std.Rectangle(_.horz_slices[s].box.left,_.vert_slices[e].box.top,_.horz_slices[s].box.width,_.vert_slices[e].box.height),TRACE_GRID&&std.logg(str.conv("horz_box={rect}, vert_box={rect}, net={rect}",_.horz_slices[s].box,_.vert_slices[s].box,l)),TRACE_GRID&&std.logg(str.conv("grid for block {} rowx={}, colx={}, box={rect}",t.blabel,e,s,l));let n=_.grid_func.name+"["+String(d)+","+String(o)+"]",i=std.new_block(t,l,BKIND_GRID_CELL,n,_.grid_func,t.dest);std.setv(M,0,i.extra,std.F_ncells,std.F_x,_.ncols),std.setv(M,0,i.extra,std.F_ncells,std.F_y,_.nrows),std.setv(M,0,i.extra,std.F_cell,std.F_x,d),std.setv(M,0,i.extra,std.F_cell,std.F_y,o),std.setv(M,0,i.extra,std.F_cell_id,std.F_x,_.horz_slices[s].id),std.setv(M,0,i.extra,std.F_cell_id,std.F_y,_.vert_slices[e].id),r=_.grid_tblr?(d-1)*_.nrows+o:(o-1)*_.ncols+d,std.setv(M,0,i.extra,std.F_cell_seq,r),std.setv(M,0,i.extra,std.F_box,std.F_left,0),std.setv(M,0,i.extra,std.F_box,std.F_top,0),std.setv(M,0,i.extra,std.F_box,std.F_width,l.width),std.setv(M,0,i.extra,std.F_box,std.F_height,l.height),std.unfreeze_draw(i,_.grid_func),o++}d++}};export function draw_slices(t){let e,s,o,d=t.div,r=0==d.vert_slices.length,l=r?d.horz_slices:d.vert_slices,_=l.length;for(o=0;o<_;o++)if((s=l[o]).id!=SKIP_SLICE&&s.box.width>0&&s.box.height>0){let l=s.drawer.name;e=std.new_block(t,s.box,BKIND_SLICE,l,s.drawer),r?(std.setv(M,0,e.extra,std.F_cell_id,std.F_x,s.id),std.setv(M,0,e.extra,std.F_cell,std.F_x,o)):(std.setv(M,0,e.extra,std.F_cell_id,std.F_y,s.id),std.setv(M,0,e.extra,std.F_cell,std.F_y,o)),std.setv(M,0,e.extra,std.F_cell_seq,o+1),std.setv(M,0,e.extra,std.F_ncells,std.F_x,d.ncols),std.setv(M,0,e.extra,std.F_ncells,std.F_y,d.nrows),std.unfreeze_draw(e,e.drawer)}};export function div_end(t){let e,s,o=t.div;TRACE_K&&std.logg(str.conv("div_end on block {str}, scrh={}, scrv={}, bounds={rect}",t.blabel,o.scrollh,o.scrollv,t.bounds)),o.open||std.argument_err("this block already been closed up"),o.open=!1,e=t.bounds.width,s=t.bounds.height,o.content_h=slices_compute(t,null!=o.grid_func,0,o.scrollh,o.horz_slices,e,s),e=t.bounds.height,s=t.bounds.width,o.content_v=slices_compute(t,null!=o.grid_func,DIVF_VERT,o.scrollv,o.vert_slices,e,s);let d=0,r=0;for(let t=0;t<o.vert_slices.length;t++)-1!=o.vert_slices[t].id&&(r+=1);for(let t=0;t<o.horz_slices.length;t++)-1!=o.horz_slices[t].id&&(d+=1);o.ncols=Math.max(1,d),o.nrows=Math.max(1,r),std.setv(M,0,t.extra,std.F_ncells,std.F_x,o.ncols),std.setv(M,0,t.extra,std.F_ncells,std.F_y,o.nrows),std.setv(M,0,t.extra,std.F_boxtot,std.F_width,o.content_h),std.setv(M,0,t.extra,std.F_boxtot,std.F_height,o.content_v)};export function div_spa(t,e,s,o){div_add(t,-1,e,s,o,null)};export function div_add(t,e,s,o,d,r,l=0,_=std.Y){if(_!=std.Y)return void div_spa(t,s,o,d);if(TRACE_K&&std.logg(str.conv("  div add, meas={n}, unit={n}",o,d)),o<=0)return;let n=new std.a_div_slice;if(n.id=e,n.drawer=r,n.draw_order=l,n.unit=d,o==std.U){let e;e=0==(s&DIVF_VERT)?new std.Rectangle(0,0,std.U,t.bounds.height):new std.Rectangle(0,0,t.bounds.width,std.U);let o=std.new_block(t,e,BKIND_MEASURING,"measuring",r,null,t.dest);o.is_measuring=!0,o.max_h=0,o.max_v=0,std.unfreeze_draw(o,o.drawer),0==(s&DIVF_VERT)?(n.mag=o.max_h,TRACE_AUTO&&std.logg(str.conv("-- after measurement, block {} width is {}",r.name,o.max_h))):(n.mag=o.max_v,TRACE_AUTO&&std.logg(str.conv("-- after measurement, block {} height is {}",r.name,o.max_v))),t.removeChild(o)}else n.mag=o;0==(s&DIVF_VERT)?t.div.horz_slices.push(n):t.div.vert_slices.push(n)};export function k_overlay(t,e){let s,o=e.name+":overlay";(s=std.new_block(t,t.bounds,BKIND_OVERLAY,o,e)).dest=t.dest,t.appendChild(s),e.code(s)};export function is_block_obsolete(t){let e,s,o=t.bseq;for(e of(TRACE_OBSOLETE&&t.blabel==OBBLOCK&&std.logg(str.conv("is_block_obsolete block={str}, ndep={}",t.blabel,t.usesz.length)),t.usesz)){TRACE_OBSOLETE&&t.blabel==OBBLOCK&&std.logg(str.conv("  testing {path}",e.path));let d=std.path_to_pathx(e.path);if(d.exists){if((s=d.lev[d.lastx].node.seq)>o)return TRACE_OBSOLETE&&std.logg(str.conv("    -- OBSOLETE, node_seq={n}, drawn_seq={n}",s,o)),!0}else if(0!=e.seq)return TRACE_OBSOLETE&&std.logg("   -- OBSOLETE: used to exist, now doesn't exist"),!0}return!1};function find_x_in_section(t,e){let s,o,d=9999999,r=-1;for(s in e.fields)(o=std.int_abs(t-e.fields[s].startdot))<d&&(d=o,r=s),(o=std.int_abs(t-(e.fields[s].stopdot-1)))<d&&(d=o,r=s);return r}function find_in_rows(t,e,s){let o,d,r,l;for(o in d=0,null!=e.vert_scroll_link&&(d=-std.getn(e.vert_scroll_link,std.F_s_position)),s.rows)if(r=s.rows[o].rowbox.top+d,l=s.rows[o].rowbox.bottom+d,TRACE_XY&&std.logg(str.conv("  find_in_rows, i={}, y={}, top={}, bot={}",o,t,r,l)),t>=r&&t<l)return o;return-1}function check_for_entry_activation(t){debugger}function find_xy_in_table(t,e,s,o){let d,r,l,_,n;if(r=find_in_rows(o,t,n=t.tbl),TRACE_XY&&std.logg(str.conv("  find_xy_in_table, local=[{n},{n}], rowx={}",s,o,r)),r>=0&&(_=n.rows[r].rowid)!=std.U){let o=n.rows[r].rowkind_ptr;if(d=find_x_in_section(s,o),l=std.U,d>=0){if(check_for_entry_activation(t,r,d,e))return TRACE_XY&&std.logg(str.conv("  absorbed by entry activation colx={}, col={}",d,l)),!0;l=o.fields[d].colid}if(TRACE_XY&&std.logg(str.conv("  sending to table tracker, colx={}, colID={n}",d,l)),l!=std.U){std.setv(M,0,t.extra,std.F_cell_id,std.F_x,l),std.setv(M,0,t.extra,std.F_cell_id,std.F_y,_),std.setv(M,0,t.extra,std.F_cell,std.F_x,d+1),std.setv(M,0,t.extra,std.F_cell,std.F_y,r+1),std.setv(M,0,t.extra,std.F_row_kind,o.kindID);let s=n.rows[r].rowbox;return std.setv(M,0,t.extra,std.F_box,std.F_left,s.left),std.setv(M,0,t.extra,std.F_box,std.F_top,s.top),std.setv(M,0,t.extra,std.F_box,std.F_width,s.width),std.setv(M,0,t.extra,std.F_box,std.F_height,s.height),t.trakfunc(t,e)}}return!1}export function callback_find_by_label(t,e){TRACE_XY&&std.logg("callback_find_by_label, testing "+t.blabel+", against "+e.targ_blabel),t.blabel==e.targ_blabel&&(e.go=!1,e.found_block=t,TRACE_XY&&std.logg("...FOUND"))};export function callback_find_any(t,e){let s;if(TRACE_XY&&std.logg("callback_find_any, block "+t.blabel),null!=t.tbl);else if(null!=t.drawer){let o=t.drawer.tracker;null!=o?(s=null!=t.drawer.parms?o.apply(null,[t,e.event].concat(t.drawer.parms)):o(t,e.event))==std.Y?(e.go=!1,e.absorber=t):TRACE_XY&&std.logg("  event was sent to block, but tracker not absorbed"):TRACE_XY&&std.logg("  inside block, no tracking func")}TRACE_XY&&!e.go&&std.logg("  CONSUMED ")};export function find_xy_in_grid(t,e,s,o){let d,r,l,_,n,i,a,c,b=t.div,g=!1;TRACE_XY&&std.logg(str.conv("  find_xy_in_grid, local=[{num}, {num}]",s,o));let u=t.drawer.tracker;if(null==u)return!1;for(n=1,r=0;r<b.horz_slices.length;r++){if(a=b.horz_slices[r].id,s>=b.horz_slices[r].box.left&&s<b.horz_slices[r].box.right){g=g||a==SKIP_SLICE;break}a!=SKIP_SLICE&&n++}for(i=1,l=0;l<b.vert_slices.length;l++){if(c=b.vert_slices[l].id,o>=b.vert_slices[l].box.top&&o<b.vert_slices[l].box.bottom){g=g||c==SKIP_SLICE;break}c!=SKIP_SLICE&&i++}return(n>b.ncols||i>b.nrows)&&(g=!0),g?(n=std.U,i=std.U,_=std.U,a=std.U,c=std.U):_=b.grid_tblr?(n-1)*b.nrows+i:(i-1)*b.ncols+n,std.setv(M,0,t.extra,std.F_cell_seq,_),std.setv(M,0,t.extra,std.F_cell,std.F_x,n),std.setv(M,0,t.extra,std.F_cell,std.F_y,i),std.setv(M,0,t.extra,std.F_cell_id,std.F_x,a),std.setv(M,0,t.extra,std.F_cell_id,std.F_y,c),(d=null!=t.drawer.parms?u.apply(null,[t,e].concat(t.drawer.parms)):u(t,e))==std.Y&&(g_last_majorx>0&&(std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_cell_cum,_),std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_cell,std.F_x,n),std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_cell,std.F_y,i),std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_cell_id,std.F_x,a),std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_cell_id,std.F_y,c),std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_absorber,t.blabel),TRACE_LOGGING&&std.logg(str.conv(" -- updating absorber to {}",t.blabel))),!0)};export function do_pointer_event(t,e,s,o,d){std.TRACE_EVENTS&&t!=std.EV_HOVER&&std.logg(str.conv("do_pointer_event, xy=[{},{}], kind={}",s,o,t));let r=new a_tree(M,"$do_pointer_event",std.NF_UNSORTED);if(std.setv(M,std.WHERE_LOOM,r,std.F_evkind,t),std.setv(M,std.WHERE_LOOM,r,std.F_when,e),std.setv(M,std.WHERE_LOOM,r,std.F_global_x,s),std.setv(M,std.WHERE_LOOM,r,std.F_global_y,o),d.mod_shf&&std.setv(M,std.WHERE_LOOM,r,std.F_is_shift,std.Y),d.mod_alt&&std.setv(M,std.WHERE_LOOM,r,std.F_is_alt,std.Y),d.mod_cmd&&std.setv(M,std.WHERE_LOOM,r,std.F_is_cmd,std.Y),d.mod_ctl&&std.setv(M,std.WHERE_LOOM,r,std.F_is_ctrl,std.Y),g_last_majorx=-1,0!=g_capture_bid)return is_not_ide(g_capture_block)&&(TRACE_LOGGING&&std.logg(str.conv(" -- adding major event captured ptr evt, first={}",g_capture_block.blabel)),g_last_majorx=std.add_major_event(r,null)),try_in_block(g_capture_block,r),void(std.getn(r,std.F_evkind)==std.EV_DRAG_END&&release_mouse());TRACE_XY&&std.logg(str.conv("about to call visit_all, mouse=({n},{n})",s,o)),t==std.EV_HOVER&&std.setv(M,0,std.runtime,std.F_cursor_changed,std.N),visit_all_containing(g_root_block,s,o,t,r),t==std.EV_HOVER&&std.getn(std.runtime,std.F_cursor_changed)!=std.Y&&std.cursor_set(std.CURS_ARROW)};export function do_key_event(t,e,s,o=!1,d=!1,r=!1,l=!1){let _;if(g_interface_locked==std.Y)return std.TRACE_EVENTS&&std.logg(str.conv("interface locked / suppressing key event, keycode=",s)),!1;let n=new a_tree(M,"$do_key_event",std.NF_UNSORTED);std.setv(M,std.WHERE_LOOM,n,std.F_evkind,std.EV_KEYBOARD),std.setv(M,std.WHERE_LOOM,n,std.F_when,t),std.setv(M,std.WHERE_LOOM,n,std.F_keycode,s),""!=e&&std.setv(M,std.WHERE_LOOM,n,std.F_unicode,e),o&&std.setv(M,std.WHERE_LOOM,n,std.F_is_shift,std.Y),d&&std.setv(M,std.WHERE_LOOM,n,std.F_is_alt,std.Y),r&&std.setv(M,std.WHERE_LOOM,n,std.F_is_cmd,std.Y),l&&std.setv(M,std.WHERE_LOOM,n,std.F_is_ctrl,std.Y);let i=std.add_major_event(n,null);TRACE_LOGGING&&std.logg(str.conv(" -- adding major event for key event at {}",i));let a=new Object;return a.go=!0,a.event=n,a.absorber=null,k_visit_blocks_bottom_up(g_root_block,callback_find_any,a),null!=(_=a.absorber)&&(is_not_ide(_)?(TRACE_LOGGING&&std.logg(str.conv("  keystroke was absorbed by {}",_.blabel)),std.setv(M,0,std.runtime,std.F_major_steps,i,std.F_hist_absorber,_.blabel)):(TRACE_LOGGING&&std.logg(str.conv("  debugger keystroke, absorbed by {}, deleting {}",_.blabel,i)),std.clear_tree(0,0,std.addr(std.runtime,std.F_major_steps,i))),!0)};function try_in_block(t,e){let s,o;TRACE_XY&&std.logg(str.conv("  try_in_block {} id={}",t.blabel,t.bid));let d=null;if(null!=t.drawer&&(d=t.drawer.tracker),null!=d){let d=global_to_local(t,s=std.getn(e,std.F_global_x),o=std.getn(e,std.F_global_y));if(std.setv(M,0,e,std.F_x,d.x),std.setv(M,0,e,std.F_y,d.y),TRACE_XY&&std.logg(str.conv("try_in_block, {str}, evkind={n}, global=[{n},{n}], local=[{n},{n}], bounds={rect}",t.blabel,std.getn(e,std.F_evkind),s,o,d.x,d.y,t.bounds)),null!=t.tbl){if(find_xy_in_table(t,e,d.x,d.y))return TRACE_XY&&std.logg("  CONSUMED by table"),!0;TRACE_XY&&std.logg("  NOT CONSUMED by table")}else if(null!=t.div&&null!=t.div.grid_func){if(TRACE_XY&&std.logg("  grid event to "+t.blabel),find_xy_in_grid(t,e,d.x,d.y))return TRACE_XY&&std.logg("  CONSUMED by grid"),!0;TRACE_XY&&std.logg("  NOT CONSUMED by grid")}else{let s;if((s=std.unfreeze_track(t,e,t.drawer))==std.Y)return TRACE_XY&&std.logg("  CONSUMED by block"),g_last_majorx>0&&(TRACE_LOGGING&&std.logg(str.conv(" -- updating absorber to {}",t.blabel)),std.setv(M,0,std.runtime,std.F_major_steps,g_last_majorx,std.F_hist_absorber,t.blabel)),!0;TRACE_XY&&std.logg("  NOT CONSUMED by block")}}return!!t.is_modal&&(TRACE_XY&&std.logg("  MODAL: silent absorption of pointer event"),!0)}export function k_visit_blocks_bottom_up(t,e,s){let o,d,r,l=t.childNodes,_=l.length;for(d=1;d<=_&&s.go;d++)(o=l[r=_-d]).hasOwnProperty("bid")&&(TRACE_VISIT&&std.logg(str.conv("  deeper to {str}",o.blabel)),k_visit_blocks_bottom_up(o,e,s));s.go&&(TRACE_VISIT&&std.logg(str.conv("k_visit_blocks_bottom_up passed to {str}, seq={n}",t.blabel,t.bseq)),e(t,s))};export function k_visit_blocks_top_down(t,e,s){s.go&&(TRACE_OBSOLETE&&std.logg(str.conv("k_visit_blocks_top_down {str}, seq={n}",t.blabel,t.bseq)),e(t,s));let o,d,r=t.childNodes,l=r.length;for(d=0;d<l&&s.go;d++)(o=r[d]).hasOwnProperty("bid")&&(gg_depth+=1,k_visit_blocks_top_down(o,e,s),gg_depth-=1)};export function k_find_block_by_label(t,e){let s,o,d,r=t.childNodes,l=r.length;for(d=0;d<l;d++)if((o=r[d]).hasOwnProperty("bid")&&null!=(s=k_find_block_by_label(o,e)))return s;return TRACE_FIND&&std.logg(str.conv("k_find_block_by_label, curr={}, targ={}",t.blabel,e)),t.blabel==e?t:null};export function k_find_block_by_locator(t,e,s){let o,d,r,l=t.childNodes,_=l.length;for(r=0;r<_;r++)if((d=l[r]).hasOwnProperty("bid")&&null!=(o=k_find_block_by_locator(d,e,s)))return o;return TRACE_FINDBX&&std.logg(str.conv("testing {str} {n}, targ {str} {n}",t.blabel,t.locator,e,s)),t.blabel==e&&t.locator==s?(TRACE_FINDBX&&std.logg("  FOUND!"),t):null};export function k_find_block_by_id(t,e){let s,o,d,r=t.childNodes,l=r.length;for(d=0;d<l;d++)if((o=r[d]).hasOwnProperty("bid")&&null!=(s=k_find_block_by_id(o,e)))return s;return t.bid==e?t:null};export function global_to_local(t,e,s){let o=e,d=s,r=t;o-=window.scrollX,d-=window.scrollY;do{o-=r.offsetLeft,d-=r.offsetTop,TRACE_GTOL&&std.logg(`global_to_local, b=${r.blabel}, sTop=${r.scrollTop}`),o+=r.scrollLeft,d+=r.scrollTop;let t=r.style.transformOrigin;if(""!=t){let e=t.split(" ");e[0].length>2&&(o-=Number(e[0].substring(0,e[0].length-2))),e[1].length>2&&(d-=Number(e[1].substring(0,e[1].length-2)))}r=r.offsetParent}while(null!=r);return TRACE_GTOL&&std.logg(`.. mapped (${e},${s}) to (${o},${d})`),new std.Point(o,d)};export function local_to_global_p(t,e=null){let s=0,o=0,d=t;null!=e&&(s=e.x,o=e.y);let r=d.style.transformOrigin;if(""!=r){let t=r.split(" ");t[0].length>2&&(s+=Number(t[0].substring(0,t[0].length-2))),t[1].length>2&&(o+=Number(t[1].substring(0,t[1].length-2)))}let l=t.getBoundingClientRect();return new std.Point(l.left+window.scrollX+s,l.top+window.scrollY+o)};export function local_to_global_r(t,e=null){let s,o=t.getBoundingClientRect();return s=null==e?new std.Rectangle(o.left+window.scrollX,o.top+window.scrollY,o.width,o.height):new std.Rectangle(o.left+window.scrollX+e.left,o.top+window.scrollY+e.top,e.width,e.height)};export function k_isolate(t,e,s,o){let d=std.new_block(t,e,BKIND_SUBSET,s,o);std.unfreeze_draw(d,o)};function visit_all_containing(t,e,s,o,d){let r,l,_,n;if(l=local_to_global_r(t),_=t.blabel==ROOT_BLABEL||std.xy_in_rect(e,s,l),TRACE_XY&&std.logg(str.conv(" testing #{}:{str}, xy=[{},{}], bounds={rect}, gbounds={rect}, inside={}",t.bid,t.blabel,e,s,t.bounds,l,_)),_){if(g_last_majorx<0&&(n=is_not_ide(t))){if(0==std.g_time_scale)return TRACE_LOGGING&&std.logg("--ignoring click while frozen"),!0;TRACE_LOGGING&&std.logg(str.conv(" -- adding major event for ptr event, first={}",t.blabel)),g_last_majorx=std.add_major_event(d,null)}let l,_,i,a=t.childNodes,c=a.length;for(_=1;_<=c;_++)if((l=a[i=c-_]).hasOwnProperty("bid")){if(TRACE_XY&&std.logg(str.conv("  recursive to child {}: {str}",_,l.blabel)),visit_all_containing(l,e,s,o,d))return!0}else TRACE_XY&&std.logg("child "+String(_)+" is not a block: "+String(l));return(r=try_in_block(t,d))&&(TRACE_XY&&std.logg("    ...absorbed event"),o==std.EV_DRAG_BEGIN&&0==g_capture_bid&&capture_mouse(t)),r}return!1}export function callback_compare_label(t,e){TRACE_K&&std.logg("callback_compare_label, "+t.blabel+" against "+e.label),t.blabel==e.label&&(e.result=t,e.go=!1)};export function callback_dump(t,e){std.logg(t.blabel+str.conv(": bounds={rect}, depth={}",t.bounds,gg_depth))};export function dump_display_list(){let t;std.logg("=== ALL BLOCKS ==="),gg_depth=0,k_visit_blocks_top_down(g_root_block,callback_dump,t={go:!0}),std.logg("=== ..end blocks.. ===")};export function k_del_all_children(t){if(null==t)return;TRACE_OBSOLETE&&std.logg("  k_del_all_children, starting at "+t.blabel);let e,s,o=t.childNodes;for(s=o.length-1;s>=0;s--){"svg"!=(e=o[s]).nodeName&&(TRACE_OBSOLETE&&std.logg(`  -removing node ${e.nodeName}`),t.removeChild(e));let d=t.last_svg_ptr;if(void 0!=d)for(;d.firstChild;)d.removeChild(d.firstChild)}};export function k_find_by_label(t){let e;return k_visit_blocks_bottom_up(g_root_block,callback_compare_label,e={go:!0,label:t,result:null}),e.result};function is_not_ide(t){if(null==t)return!0;for(;null!=t;){if(t==g_root2_block)return!0;t=t.parentNode}return!1}export function rebuild_affected_blocks(t){let e,s;if(TRACE_OBSOLETE&&t.blabel==OBBLOCK&&std.logg(str.conv("rebuild_affected block={str}, id={n}, seq={n}, ndep={}",t.blabel,t.bid,t.bseq,t.usesz.length)),e=!0,is_block_obsolete(t)&&(TRACE_OBSOLETE&&std.logg("  OBSOLETE "+t.blabel),s=document.activeElement.id,LOG_DRAW&&g_first_mon_draw&&is_not_ide(t)&&(g_first_mon_draw=!1,std.add_major_event(DRAW_EVENT,t)),null!=t.drawer.parms?t.drawer.code.apply(null,[t].concat(t.drawer.parms)):t.drawer.code(t),TRACE_OBSOLETE&&std.logg(str.conv("  ..end rebuild of {str}, seq={n}",t.blabel,t.bseq)),e=!1,""!=s)){var o=document.getElementById(s);null!=o&&o.focus()}if(e){let e,s,o=t.childNodes,d=o.length;for(s=0;s<d;s++)(e=o[s]).hasOwnProperty("bid")&&rebuild_affected_blocks(e)}};export function rebuild_all(){var t,e=std.getn(std.runtime,std.F_major_firstx);if(e==std.U&&(e=std.getn(std.runtime,std.F_major_stepx),std.setv(M,0,std.runtime,std.F_major_firstx,e)),null!=(t=null!=std.aaaa.mon_drawer?std.aaaa.mon_drawer:std.aaaa.main_drawer)){for(var s=document.body;s.firstChild;)s.removeChild(s.lastChild);let e=window.innerWidth,o=window.innerHeight;std.setv(M,0,std.runtime,std.F_window_horz,e),std.setv(M,0,std.runtime,std.F_window_vert,o),TRACE_K&&std.logg(`---\x3e rebuild_all: horz=${e} x ${o}`);let d=new std.Rectangle(0,0,e,o);if(g_root_block=std.new_block(null,d,BKIND_ROOT,ROOT_BLABEL,t),document.body.appendChild(g_root_block),null!=t.tracker){let e=new a_tree(M,"$resize_event");std.setv(M,0,e,std.F_evkind,std.EV_RESIZE),std.setv(M,0,e,std.F_when,0),LOG_DRAW&&std.add_major_event(e,g_root_block),t.tracker(g_root_block,e)}LOG_DRAW&&std.add_major_event(DRAW_EVENT,g_root_block),t.code(g_root_block),TRACE_K&&dump_display_list()}};export function check_tree_for_dirty(t){let e,s;for(e of(s=!1,t.children))0!=(e.eflags&std.EF_IS_DERIVED)&&(TRACE_OBSOLETE&&std.logg(str.conv("  checking child.sub={n}",e.sub)),g_fields_to_mark.indexOf(e.sub)>=0&&(TRACE_OBSOLETE&&std.logg(str.conv("  marking field as dirty {n}",e.sub)),e.eflags|=std.EF_IS_DIRTY,s=!0)),s&&(t.seq=std.g_currseq),null!=e.children&&check_tree_for_dirty(e)};export function trickle(t){let e,s;if(null!=g_root_block){if(0!=g_fields_to_mark.length){if(TRACE_TRICKLE)for(s of(std.logg("trickle, checking for marked fields, nmarked="+String(g_fields_to_mark.length)+", marked_fields="),g_fields_to_mark))std.logg(str.conv(" {n}",s));for(e of std.TREES)TRACE_TRICKLE&&std.logg("trickle, check top node "+e.val),check_tree_for_dirty(e);g_fields_to_mark.length=0}TRACE_TRICKLE&&g_last_drawn_seq!=std.g_currseq&&std.logg(str.conv("trickle, last_drawn={}, currseq={}",g_last_drawn_seq,std.g_currseq)),g_last_drawn_seq<std.g_currseq&&(g_first_mon_draw=!0,rebuild_affected_blocks(g_root_block),null!=std.aaaa.menubar_func&&(g_first_mon_draw=!1,rebuild_affected_blocks(g_menu_block)),g_last_drawn_seq=std.g_currseq,TRACE_TRICKLE&&std.logg(str.conv("..end trickle, last_drawn={n}",g_last_drawn_seq)))}};export function k_init(){DRAW_EVENT=new a_tree(M,"$DRAW_EVENT"),std.setv(M,0,DRAW_EVENT,std.F_evkind,std.EV_DRAW),g_interface_locked=!1,g_capture_bid=0,g_capture_block=null,g_field_mark_func={},g_fields_to_mark=[],g_last_drawn_seq=1e3};